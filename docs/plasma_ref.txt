Plasma Language Reference
=========================
Paul Bone <paul@plasmalang.org>
v0.1, October 2015: Initial draft.
Copyright (C) 2015 Plasma Team
License: CC BY-SA 4.0

As the language is under development this is a working draft.
Many choices may be described only as bullet points.
As the language develops these will be filled out and terms will be
clarified.

== Lexical analysis and parsing

* Input files are UTF-8
* Curly braces for blocks/scoping
* Whitespace is only significant when it separates two tokens what would otherwise form a single token
* either newlines or semicolons delimit statements and declarations (NIY)

=== Parsing

Plasma's draft EBNF is as follows.  In this ENBF syntax I use ( and ) to
denote groups and ? + and * to denote optional, one or more, and zero or
more.

----
    Plasma := ModuleDecl ToplevelItem*

    ModuleDecl := module ident

    ToplevelItem := ExportDirective
                  | ImportDirective
                  | FuncDefinition

    ExportDirective := export IdentList
                     | export *
    ImportDirective := import IdentList

    FuncDefinition := func ident '(' ( Param ( , Param )* )? ')' ->
                          TypeExpr Using* Block

    Param := ident : TypeExpr

    # Using donotes which resources a function may use.
    Using := using IdentList
           | observing IdentList

    TypeExpr := Type
              | Type '(' TypeExpr ( , TypeExpr )* ')'

    Type := ident

    Block := '{' Statement* '}'

    Statement := '!' Statement      % An effectful/observing
                                    % statement
               | Expr

    Expr := ident                           % A value
          | const_str                       % A constant value
          | Expr \( Expr ( , Expr )* \)     % A call

    IdentList := ident ( , ident )*
----

There is a lot missing.  Some changes I intend to make are:

TODO: Probably add support for naming return parameters

TODO: Add support for multiple return

TODO: More expressions and statements

=== A note on case and style.

Sometimes it is necessary to use case to distinguish symbols in
different namespaces that may appear in the same expression.  For example
type names and type variables can both appear in type expressions.  In other
situations there is no requirement but it can be useful to adopt a
convention that makes it easier to read code.

Plasma either requires or suggests the following cases in the following
situations.

|===
|                  | Requirement          | Suggestion  | Notes
| Variable         | -                    | lower_case  |
| Function Name    | -                    | lower_case  |
| Module Name      | -                    | UpperCase   | Case insensitive
| Type Name        | first letter capital | UpperCase   |
| Type Variable    | first letter lower   | lower_case  |
| Data constructor | -                    | UpperCase   | to visually distinguish construction from function application.
| Field selector   | -                    | lower_case  |
| Interface        | ?                    | UpperCase   |
| Instance         | ?                    | lower_case  | not first class,
but may appear in expressions.
| Resources        | -                    | lower_case  |
|===

Note that there may be more symbol namespaces in the future.

The rationale for these decisions is:

.Variables, functions and field selectors
The most common symbols should be in lower case and use '_' to separate
words are preferred, but not enforced.

.Module names
It is useful to visually distinguish module names from other symbols that
can appear within expressions.  Currently module names can only be used to
module-qualify other symbols, but this may change in the future.  This may
also become a requirement rather than a suggestion.

.Types and type variables
Type variables must be distinguished from types.  Note that variables
don't need to be distinguished from functions as this is available from
context: free variables do not exist and a bound variable has the same
semantics as a defined function name.

Therefore plasma uses case to distinguish between type names (uppercase
first letter) and type variables (lowercase first letter).

----
    List(t)
----

Is a list of _t_ where +List+ is the list type and +t+ is a type
variable, it may stand for any type.  Note that this is the same as
Haskell but the opposite of Mercury.

.Data constructors
Code that does different things should look different.
Therefore data construction should stand apart from function calls, and
hence it is useful if data constructors to begin with capital letters.
It could be argued that the same is true for field selection.  Suggestions
welcome.

.Interfaces and Interface Instances
Interfaces are to instances as types are to values,
This is reflected in our decision to suggest that interfaces should be
CamelCase and instances lower_case.
Also, instances and module qualifiers can both appear within
expressions as a prefix to another symbol.
Instances will also appear distinct from module qualifiers.

== Modules

Each file is a module, the file name must match the module name (case
insensitive).  By convention CamelCase is used.

NOTE: I prefer lower case filenames, but I also want these to match.  Maybe
I'll grow to like CamelCase file names.

Each module begins with a module declaration.

----
    module my_module
----

=== Module Imports

Modules may be imported with a use or import declaration.

----
    use IO
    import RBTreeMap
    import RBTreeMap as Map
    import IO.getpid as getpid
----

+use+ will add the module's contents to the current environment.  So the
declaration on line 1 will import all symbols (open, getpid etc) into the
current environment, meaning that module qualification is not required to
use those symbols, however it may be used to avoid ambiguity either for
human readers or the compiler.  So +use IO+ adds +getpid+ and +IO.getpid+ to
the environment.

+import+ declares that we will use that module and how
we can access its contents.  The declarations on lines 2 and 3 add a
module name (+RBTreeMap+ or +Map+, respectively) to the current environment.
The forth declaration imports only the +getpid+ function from +IO+ and names
it +getpid+ in the current environment.

You may be thinking that the third use of +import+ should be use; since it
adds a function, rather than a module, to the current environment.  However
the distinction that I'm making between use and import is that +import+
*explicitly* updates the environment, you can always look at an import
declaration and know which new symbols are available.  Whereas +use+ can
update the environment in non-obvious ways.

A module cannot be used with either a +use+ or +import+ declaration.

Bindings created by import shadow pre-existing bindings.  It is an error for
more than on import to bind the same symbol in the same scope level:

----
    import SortedListSet as Set
    import RBTreeSet as Set
----

Is illegal.  However

----
    import SortedListSet as Set
    ...
    // some code
    ...
    {
        import RBTreeSet as Set
        ...
        // some code using RBTreeSets
        ...
    }
    ...
    /// back to SortedListSet
    ...
----

is permitted.
(Yes, module imports may appear within function bodies and so-on.)

TODO: Figure out if context always tells us enough about the role of a
symbol that modules do not need to shadow types and constructors.  I suspect
this is true but I'll have to define the rest of the language first.

+use+ can shadow existing bindings.  Symbol resolution works with and
without module qualification, recall that +use IO+ adds +getopt+ and
+IO.getopt+ to the environment:

* Unambiguous match: if there is a single unique match it is resolved using
  that match.
* Local first: If the symbol is unqualified and there is a matching symbol
  in the local module/scope (scope refers to interfaces & instances below)
  then the symbol is resolved.
* Exact module qualification: If there is a matching symbol with the exact
  module qualifiers.  +IO.getpid+ matches exactly +IO.getpid+ but not
  +System.IO.getpid+ then that the symbol is resolved.
* Failure.

=== Module exports

Symbols can be exported with export directives.

----
    export my_function
----

If a module has no export directives then nothing is exported.  Which
probably makes the module useless.

To export everything from a module use a +*+.

----
    export *
----

TODO: Syntax for exporting types abstractly & fully.

== Types

* Algebraic types
* parametric polymorphism (aka generics)
* Abstract types
* Other features may be considered for a later version
* Type variables are lower case, type names begin with an uppercase letter
  (Haskell style)

=== Builtin types

How "builtin" these are varies.  Ints are completely builtin and handled by
the compiler where as a List has some compiler support (for special symbols
& no imports required to say "List(t)") but operations may be via library
calls.

* Int
* Uint
* Int8, Int16, Int32, Int64
* Uint8, Int16, Int32, Int64
* Char (a unicode codepoint)
* Float (NIY)
* Array(t)
* List(t)
* String (neither a CString or a list of chars).
* Higher order types

These types are implemented in the standard library.

* CString
* Map(t)
* Set(t)
* etc...

=== User types

User defined types support descriminated unions (here a +Map+ is
either a +Node+ or +Empty+), and generics (k and v are type parameters).

----
  type Map(k, v) = Node(
                        m_key   :: k,
                        m_value :: v,
                        m_left  :: Map(k, v),
                        m_right :: Map(k, v)
                    )
                  | Empty
----

TODO: Syntax will probably change, I don't like +,+ as a seperator, I prefer
a terminator, or nothing to match the rest of the language.  Curly braces?
+|+ is also used as a seperator here.

Types may also be defined abstractly, with their details hiden behind module
abstraction.

== Interfaces

Interfaces are a lot like OCaml modules.  They are not like OO classes and
only a little bit like Haskell typeclasses.

Interfaces are used to say that some type and/or code behave in a particular
way.

The +Ord+ interface says that values of type +Ord.t+ are totally ordered
and provides provide a generic compassion function for +Ord.t+.

----
    type CompareResult = LessThan | EqualTo | GreaterThan

    interface Ord {
        type t

        compare(t, t) -> CompareResult
    }
----

+t+ is not a type parameter but +Ord+ itself may be a parameter to another
interface, which is what enables +t+ to represent different types in different
situations; +compare+ may also represent different functions in different
situations.

We can create instances of this interface.

----
    instance ord_int : Ord {
        type t = Int

        compare(a : Int, b : Int) -> CompareResult {
            if (a < b) {
                LessThan
            } else if (a > b) {
                GreaterThan
            } else {
                EqualTo
            }
        }
    }
----

Note that in this case each member has a definition.  This is what makes
this an interface instance (plus the different keyword), rather than an
(abstract) interface.  The importance of this distinction is that interfaces
cannot be used by code directly, instances can.

Code can now use this instance.

----
    r = ord_int.compare(3, 4)
----

Interfaces can also be used as parameter types for other interfaces.
Here we define a sorting algorithm interface using an instance (+o+) of the
+Ord+ interface.

----
    interface Sort {
        type t
        sort(List(t)) -> List(t)
    }

    instance merge_sort(o : Ord) : Sort {
        type t = o.t
        sort(l : List(t)) -> List(t) {
            ...
        }
    }
----

+merge_sort+ is an instance, each of its members has a definition, but it
cannot be used without passing an argument (an instance of the +Ord+
interface).  A list of +Int+s can now be sorted using:

----
    sorted_list = merge_sort(ord_int).sort(unsorted_list)
----

NOTE: This example is somewhat contrived, I think it'd be more convenient
for sort to take a higher order parameter.  But the example is easy to
follow.

+merge_sort(ord_int)+ is an interface expression, so is +ord_int+ in the
example above.
Interface expressions will also allow developers to name and reuse specific
interfaces, for example:

----
    interface s = merge_sort(ord_int)
    sorted_list = s.sort(unsorted_list)
----

More powerful expressions may also be added.

== Code

=== Functions

Code is organised into functions.

A function has the following form.

----
    Name(arg1 : type1, arg2 : type2, ...) -> ret_type1, ret_type2
            Resources?
    {
        Statements
    }
----

If the types are omitted from a non-exported function's argument list the
compiler will attempt to infer them.

TODO: Find a way that return parameters can be named.  This will change the
behaviour of functions WRT having the value of their last statement.

TODO: Can the type of a return value be inferred?

TODO: What if neither the name or type of a return value is specified?

Resources is optional and may either or both "using" or "observing" clauses,
which are either the using or observing keywords followed by a list of one
or more comma separated resource names.

=== Statements

Statements may be assignments.

----
    variable = expr
----

Which may be multiple-value expressions.

----
    var1, var2 = expr1, expr2

    var1, var2 = expr # expr returns a two items.
----

Calls (which are also expressions)

----
    function_name(Args);
----

Return

----
    return expr

    return expr1, expr2
----

Or control flow

----
    if (expr) {
        statements
    } else if (expr) {
        statements
    } else {
        statements
    }
----

There may be zero or more else if parts.

Plasma is a single assignment language.  Each variable can only be assigned
to once along any execution path, and must be assigned on each execution
path that returns normally.  This means that an if statement that assigns to
some variable "X" in one branch, must do so in all the other branches.  This
implies that if the statement binds anything at all, then it must have an
"else" branch.

----
    if (...) {
        X = ...
    } else {
        X = ...
    }
----

Since Plasma is a multiple return language a statement may assign more than
one value, because expressions may have more than one value.

----
    X, Y = foo(), bar();

    // or if baz returns two results.
    X, Y = baz();
----

=== Expressions

All expressions are also statements and all statements are also expressions.
The value of a block of statements is the value of the last statement in that
block.  If the block, or the statement itself is a branching structure, the
value is the last statement in the executed branch (see below).

Any control-flow statement is also an expression.

----
    X = if (...) { statements } else { statements }
----

In this case the branches cannot bind anything visible outside of
themselves, and the value of a branch is the value of the last statement in
that branch.

If a multi-return expression is used as a subexpression in another context
then that expression is in-turn duplicated.

----
    x, y = multi_value_expr + 3
----

is

----
    x0, y0 = multi_value_expr
    x = x0 + 3
    y = y0 + 3
----

Therefore calls involved in these expressions must not "use resources".

TODO: Maybe as an alternative to the above, but I doubt it.

A multiple return expression in the context of function application
applies as many arguments as values it returns.

----
    ... = bar(foo(), Z);
----

Is the same as

----
    X, Y = foo();
    ... = bar(X, Y, Z);
----

== Handling effects (IO, destructive update)

Plasma is a pure language, we need a way to handle effects like IO and
destructive update.  This is called resources.  A declaration for main, which
uses the IO resource looks like.

----
    Int main() using IO
----

Functions have resource annotations.  Resources can be "used" or "observed"
and a function may use or observe any number of resources (decided
statically).  An observed resource may be read but is never updated, a used
resource may be read or updated.  This distinction allows two uses of an
observed resource to commute (code may be re-arranged during optimisation).

Developers may declare new resources, the standard library will provide some
resources.

A caller to a function that uses a resource, must be holding that resource
in the correct mode: either "uses" or if the callee only needs observe then
either "uses" or "observes".

Creating and destroying resources is a special case of "using" that
resource.  The resource will be unusable before and after creating and
destroying them respectively.  If a resource is created and destroyed in the
same function, then that function does not require the "using" annotation
for that resource.

=== Higher order code

If we allow resource-using functions to be passed as higher order values
then the function we pass them to must "become" a higher order using
function itself. However there are some problems.

 * Storing a reference of a function that uses some resource.
 * The order of effects in something like map or fold
 * The order of effects, and associativity and commutativity in Plasma's
   loops.

=== Linking to and storing as data

Linking a resource with a _real_ piece of data, such as a file descriptor,
will be necessary.  Likewise putting resources inside a structure to be used
later, such as a pool of warmed-up database connections, will also be
necessary.

It seems that both these can be accomplished with the same solution.  We
need to add an additional attribute to some types to say that they are also
resources, so that the variable can stand-in for the resource.

----
    write(Fd, ...) using Fd
----

There may also be a syntax sugar for this.  Uniqueness will also need to be
added to types so that there is only one active user of a resource at once.
How this behaves with structures may still be a problem.

=== Commutativity of resources

Optimisation may cause code to be executed in a different order than
written.  The following reorderings are legal.

|===
|           | None  | Observe   | Use
| None      | Y     | Y         | Y
| Observe   | Y     | Y         | N
| Use       | Y     | N         | N
|===

Generally operations on different resources may always commute, such as two
distinct file descriptors.  The exception to this is that IO may not
generally commute.  The logic works as follows:

----
    may_commute(R1, R2)
        if (R1 = IO or R2 = IO)
            consult table above
        else if (R1 = R2)
            consult table above
        else
            may commute.
----

