Plasma Abstract Machine
=======================
Paul Bone <paul@plasmalang.org>
v0.1, September 2015: Initial draft.
Copyright (C) 2015 Plasma Team
License: CC BY-SA 4.0

This document describes the behaviour of the Plasma Abstract Machine (PZ
Machine).  The PZ file format is described in link:pz_format.html[PZ
Bytecode Format].  and implementations of the PZ abstract machine are
discussed elsewhere (TODO)

In this document we use the textual version of the .pz files for
illustrative purposes.  However the textual format is never used as an
interchange format and rarely used as a language so it does not need or have
a specification.

== Basic data types

The abstract machine supports words of varying sizes, with the symbols
representing them.

- 8bit (+w8+)
- 16bit (+w16+)
- 32bit (+w32+)
- 64bit (+w64+)
- fast word width (+w+)
- a word width the same width as a pointer (+wptr+)
- a pointer (+ptr+)

A fast word width is a width that should be the fasted word width for
integers on the platform.  This may take into account register size, memory
usage and maybe implementation convenience.  A word with the same width as a
pointer and a pointer differ only in whether the garbage collector may trace
them.  Which is significant in some contexts (like structures) but not in
others (like instruction parameter widths).

Some instructions only make sense with either signed or unsigned data, this
is up to individual instructions, the PZ format and abstract machine don't
care.  This way "move a 32bit word" makes sense regardless of whether the
word is signed, unsigned, or something else (float, bitfield etc).

The PZ machine also supports structures and arrays, more on those later.

== Registers

The PZ Machine is a stack based machine, it has a single register: the
program counter (PC).  The program counter "points to" the next instruction
to execute.

== Stacks

The basic abstract machine is a stack machine with two stacks.  A return
stack and an expression stack.  The return stack is used to handle procedure
call and return.  Very little control of the return stack is available.
Both basic instructions and procedures are a transformation of
the top of the expression stack.

== Notation

A procedure or instruction's signature may look like:

    + (w w - w)

This describes the instruction + as taking two words from the top of stack
and replacing them with a word.  Calling conventions for procedures work the
same way.  The expression stack is used for argument passing and temporary
storage.

    fibs (w - w)

From a callee's perspective, there is little difference between an
instruction and a call.

If an instruction is available for all word sizes it may be written as:

    + (* * - *)

This is a convention only, there is no support for polymorphism.  When using
the textual format for PZ, you may disambiguate which instruction you need
with a suffix.

eg:

    +:8
    +:16
    +:32
    +:64
    +:w   (fast word width)
    +     (no suffix also means fast word width)
    +:ptr (pointer word width)

This works similarly for literal data.  This is a byte containing the number
23.

    23:8

This is only available for instructions, not calls.

Also in our notation we indicate immediate data with CamelCase, and in the
case of calls and literal data, the instruction name is not provided.  The
instruction to use is available via context.

== High level bytecode items

Each item in a bytecode file belongs in one of three types and is referred
to by a 32bit ID.  Each item type has its own ID-space.  In other words data
item 5 and procedure 5 are separate.  Names are used in .pzt files but are
discarded when these are compiled to .pz files.  The exceptions are imported
items, exported items (TODO), and in the future some names and other
information may be stored for debugging.

=== Structs

A struct is a record type, and has a lot in common with a C struct.  Each
struct has a fixed number of fields and each field has a width (as above).
Structs allow the bytecode interpreter to make its own data layout
decisions.  Which it may do differently on different platforms.  They are
also provide information for the garbage collector.

=== Data

Data items come in three types:

 * Basic data: a single data item of a specific width.
 * Array data: a number of data items of the same width, usually packed
   together.
 * Structure data: a structure of data, the data item provides the struct ID
   and the value of each field.

TODO: Separate read-only / read-write.

=== Procedures

Procedures contain executable code.  A procedure's signature is a "stack
transformation" it represents the top of stack values before and after a
call to this procedure.  This is explained above.

Procedures are made up of blocks which are used for control flow.  The first
block in each procedure is executed when the procedure is called.  Within
each procedure blocks are numbered sequentially starting at 0.  Jump
instructions refer to their destination by block ID.

Note that execution can never "fall through" a block, the last instruction
in every block must be an unconditional control flow instruction.

== Instructions

Each instruction is made from an opcode, between zero and two operand widths
and optionally an immediate value.

=== Zero extend, Sign extend and Truncate

    ze (* - *)
    se (* - *)
    trunc (* - *)

Zero extends, sign extends or truncates the value on the top of the stack.
By truncate we mean discard the most significant bytes.  While most
instructions work on a single operand width, these instructions use two
operand widths.  For example.

    ze (w16 - w32)

Note that it is not necessary (or advised) to use these instructions to
convert to and from pointer data, for example to manipulate tagged pointers.

=== Arithmetic: add, sub, mul, div and mod.

    add (* * - *)
    sub (* * - *)
    mul (* * - *)
    div (* * - *)
    mod (* * - *)

Integer addition, subtraction, multiplication, division and modulus.

=== Comparison: lt_u, lt_s, gt_u, gt_s

    lt_u (* * - w)
    lt_s (* * - w)
    gt_u (* * - w)
    gt_s (* * - w)

Less than and greater than on unsigned and signed data.  Note that the
result is always fast word width.  Likewise conditional instructions always
take their argument in the fast word width.

=== Stack manipulation: dup, drop, swap

    dup (* - * *)

Push a copy of the top of stack item onto the stack.

    drop (* -)

Drop the top of stack item.

    swap (*A *B - *B *A)

Swap the two top of stack items.  This instruction manipulates data of
different data widths.

NOTE: Consider adding +pick+ and +dropn+

=== Procedure calls: call and ret

    ProcId (-)

Call the procedure given by ProcId.  Push the value of the program counter
onto the return stack and load the program counter with the address of the
first instruction in the first block of the procedure.

    ret (-)

Pop the value off the return stack and load it into the program counter
register.

TODO: Indirect calls

=== Jumps: cjmp

    cjmp BlockId (w -)

Pop a value of the expression stack, if it is non-zero load the address of
the first instruction of the given block into the program counter.

Note that this instruction always consumes the value on the stack.

Note that only blocks can be the target of jump instructions, this way all
jmp targets are known.

TODO: jmp

TODO: indirect jumps or some mechanism for computed gotos.

=== Loops

TODO: Some loops may be handled differently than using blocks and jumps,

=== Data

==== Load immediate number

    N (- *)

Loads the immediate value onto the expression stack.  (N is any value).

==== Load data reference

    DataId (- ptr)

Loads the address of the static data referenced by DataId.  (DataId is the
ID of any static data).

==== Load and store memory

    load (ptr - *)

Read the value from memory at the given address.

    store (ptr * -)

Store a value into memory.

TODO: Make sure that we can easily handle memory barriers for GC.

==== Address offsets

    offset StructId FieldNum (ptr - ptr)

Compute the offset within a structure of the given field.  StructId and
FieldNum are literal.

Alternatively this could just return the offset, the caller would have to
add it to the given address.  Would this be better?

    offset StructId FieldNum (- wptr)

==== Memory allocation

    alloc StructId (- ptr)
    alloc_mutable StructId (- ptr)

    alloc_array ElementWidth (w - ptr)
    alloc_array_mutable ElementWidth (w - ptr)

Plasma will use immutable structures more often than mutable ones, so
immutable is the "normal" type.
Note that this does not prevent store from being used on immutable data,
but doing so would be bad.
The GC among other things will use immutability information to optimise its
algorithms.

== Garbage collection

TODO

TODO: Handle tagged pointers.

== Linking to other modules

TODO

== Working with foreign code

TODO

== Using PZ

=== A note about data

The stack cannot be used to store complex data, neither can it be
intermediate in the instruction stream.  Complex data (structs and arrays)
must be either statically allocated or allocated on the heap.  In either
case the PZ machine needs to about the structure or array being used.

